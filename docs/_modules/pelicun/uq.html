

<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" />
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  
  <title>pelicun.uq &mdash; pelicun  documentation</title>
  

  
  <link rel="stylesheet" href="../../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../../_static/sphinxcontrib-images\LightBox2\lightbox2\css\lightbox.css" type="text/css" />
  <link rel="stylesheet" href="../../_static/css/custom.css" type="text/css" />

  
  

  
  

  

  
  <!--[if lt IE 9]>
    <script src="../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../../" src="../../_static/documentation_options.js"></script>
        <script src="../../_static/jquery.js"></script>
        <script src="../../_static/underscore.js"></script>
        <script src="../../_static/doctools.js"></script>
        <script src="../../_static/sphinxcontrib-images\LightBox2\lightbox2\js\jquery-1.11.0.min.js"></script>
        <script src="../../_static/sphinxcontrib-images\LightBox2\lightbox2\js\lightbox.min.js"></script>
        <script src="../../_static/sphinxcontrib-images\LightBox2\lightbox2-customize\jquery-noconflict.js"></script>
    
    <script type="text/javascript" src="../../_static/js/theme.js"></script>

    
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
<script src="https://cdn.jsdelivr.net/npm/vega@5.12.1"></script>
<script src="https://cdn.jsdelivr.net/npm/vega-lite@4.13.1"></script>
<script src="https://cdn.jsdelivr.net/npm/vega-embed@6.8.0"></script>
<style media="screen">.vega-actions a {margin-right: 5px;}</style>
<link href="../../_static/css/bootstrap.css" rel="stylesheet">

</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search"  style="background: #F2F2F2" >
          
<a href="https://simcenter.designsafe-ci.org/" style="margin-bottom: 0px;">
  <img src="../../_static/img/SimCenter-Only.png" class="logo" alt="Org-Logo" />
</a>
<hr style="margin: 0px;">

  <a href="../../index.html">



  
  <img src="../../_static/pelicun-Logo.png" class="logo" alt="Logo"/>

</a>


  
  



<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>


        </div>

        
        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption"><span class="caption-text">About</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../common/user_manual/about/pelicun/about.html">1. About</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../common/front-matter/pelAck.html">2. Acknowledgments</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../common/front-matter/license.html">3. Copyright and License</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../common/front-matter/glossary.html">4. Glossary</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../common/front-matter/abbreviations.html">5. Abbreviations</a></li>
</ul>
<p class="caption"><span class="caption-text">User Manual</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../common/user_manual/installation/pelicun/installation.html">1. Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../common/user_manual/usage/pelicun/usage.html">2. User Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../common/user_manual/troubleshooting/pelicun/troubleshooting.html">3. Troubleshooting</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../common/reqments/reqPelicun.html">4. Requirements</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../common/user_manual/bugs.html">5. Bugs &amp; Feature Requests</a></li>
</ul>
<p class="caption"><span class="caption-text">Technical Manual</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../common/technical_manual/pelicun/background/background.html">1. Background</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../common/technical_manual/pelicun/verification/verification.html">2. Verification</a></li>
</ul>
<p class="caption"><span class="caption-text">Developer Manual</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../common/developer_manual/coding_style/pelicun/coding_style.html">1. Coding Style</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../common/developer_manual/API/pelicun/API.html">2. API Documentation</a></li>
</ul>

            
          
        </div>
        
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">pelicun</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          

















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../../index.html" class="icon icon-home"></a> &raquo;</li>
        
          <li><a href="../index.html">Module code</a> &raquo;</li>
        
      <li>pelicun.uq</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <h1>Source code for pelicun.uq</h1><div class="highlight"><pre>
<span></span><span class="c1"># -*- coding: utf-8 -*-</span>
<span class="c1">#</span>
<span class="c1"># Copyright (c) 2018 Leland Stanford Junior University</span>
<span class="c1"># Copyright (c) 2018 The Regents of the University of California</span>
<span class="c1">#</span>
<span class="c1"># This file is part of pelicun.</span>
<span class="c1">#</span>
<span class="c1"># Redistribution and use in source and binary forms, with or without</span>
<span class="c1"># modification, are permitted provided that the following conditions are met:</span>
<span class="c1">#</span>
<span class="c1"># 1. Redistributions of source code must retain the above copyright notice,</span>
<span class="c1"># this list of conditions and the following disclaimer.</span>
<span class="c1">#</span>
<span class="c1"># 2. Redistributions in binary form must reproduce the above copyright notice,</span>
<span class="c1"># this list of conditions and the following disclaimer in the documentation</span>
<span class="c1"># and/or other materials provided with the distribution.</span>
<span class="c1">#</span>
<span class="c1"># 3. Neither the name of the copyright holder nor the names of its contributors</span>
<span class="c1"># may be used to endorse or promote products derived from this software without</span>
<span class="c1"># specific prior written permission.</span>
<span class="c1">#</span>
<span class="c1"># THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quot;AS IS&quot;</span>
<span class="c1"># AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE</span>
<span class="c1"># IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE</span>
<span class="c1"># ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE</span>
<span class="c1"># LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR</span>
<span class="c1"># CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF</span>
<span class="c1"># SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS</span>
<span class="c1"># INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN</span>
<span class="c1"># CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)</span>
<span class="c1"># ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE</span>
<span class="c1"># POSSIBILITY OF SUCH DAMAGE.</span>
<span class="c1">#</span>
<span class="c1"># You should have received a copy of the BSD 3-Clause License along with</span>
<span class="c1"># pelicun. If not, see &lt;http://www.opensource.org/licenses/&gt;.</span>
<span class="c1">#</span>
<span class="c1"># Contributors:</span>
<span class="c1"># Adam Zsarn√≥czay</span>

<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">This module defines constants, classes and methods for uncertainty</span>
<span class="sd">quantification in pelicun.</span>

<span class="sd">.. rubric:: Contents</span>

<span class="sd">.. autosummary::</span>

<span class="sd">    mvn_orthotope_density</span>
<span class="sd">    fit_distribution</span>
<span class="sd">    RandomVariable</span>
<span class="sd">    RandomVariableSet</span>
<span class="sd">    RandomVariableRegistry</span>


<span class="sd">&quot;&quot;&quot;</span>

<span class="kn">from</span> <span class="nn">.base</span> <span class="kn">import</span> <span class="o">*</span>

<span class="kn">from</span> <span class="nn">scipy.stats</span> <span class="kn">import</span> <span class="n">uniform</span><span class="p">,</span> <span class="n">norm</span>
<span class="kn">from</span> <span class="nn">scipy.stats</span> <span class="kn">import</span> <span class="n">multivariate_normal</span> <span class="k">as</span> <span class="n">mvn</span>
<span class="kn">from</span> <span class="nn">scipy.stats.mvn</span> <span class="kn">import</span> <span class="n">mvndst</span>
<span class="kn">from</span> <span class="nn">scipy.linalg</span> <span class="kn">import</span> <span class="n">cholesky</span><span class="p">,</span> <span class="n">svd</span>
<span class="kn">from</span> <span class="nn">scipy.optimize</span> <span class="kn">import</span> <span class="n">minimize</span>

<span class="kn">import</span> <span class="nn">warnings</span>


<div class="viewcode-block" id="mvn_orthotope_density"><a class="viewcode-back" href="../../common/developer_manual/API/pelicun/API_pelicun_uq.html#pelicun.uq.mvn_orthotope_density">[docs]</a><span class="k">def</span> <span class="nf">mvn_orthotope_density</span><span class="p">(</span><span class="n">mu</span><span class="p">,</span> <span class="n">COV</span><span class="p">,</span> <span class="n">lower</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">upper</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Estimate the probability density within a hyperrectangle for an MVN distr.</span>

<span class="sd">    Use the method of Alan Genz (1992) to estimate the probability density</span>
<span class="sd">    of a multivariate normal distribution within an n-orthotope (i.e.,</span>
<span class="sd">    hyperrectangle) defined by its lower and upper bounds. Limits can be</span>
<span class="sd">    relaxed in any direction by assigning infinite bounds (i.e. numpy.inf).</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    mu: float scalar or ndarray</span>
<span class="sd">        Mean(s) of the non-truncated distribution.</span>
<span class="sd">    COV: float ndarray</span>
<span class="sd">        Covariance matrix of the non-truncated distribution</span>
<span class="sd">    lower: float vector, optional, default: None</span>
<span class="sd">        Lower bound(s) for the truncated distributions. A scalar value can be</span>
<span class="sd">        used for a univariate case, while a list of bounds is expected in</span>
<span class="sd">        multivariate cases. If the distribution is non-truncated from below</span>
<span class="sd">        in a subset of the dimensions, use either `None` or assign an infinite</span>
<span class="sd">        value (i.e. -numpy.inf) to those dimensions.</span>
<span class="sd">    upper: float vector, optional, default: None</span>
<span class="sd">        Upper bound(s) for the truncated distributions. A scalar value can be</span>
<span class="sd">        used for a univariate case, while a list of bounds is expected in</span>
<span class="sd">        multivariate cases. If the distribution is non-truncated from above</span>
<span class="sd">        in a subset of the dimensions, use either `None` or assign an infinite</span>
<span class="sd">        value (i.e. numpy.inf) to those dimensions.</span>
<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    alpha: float</span>
<span class="sd">        Estimate of the probability density within the hyperrectangle</span>
<span class="sd">    eps_alpha: float</span>
<span class="sd">        Estimate of the error in alpha.</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># process the inputs and get the number of dimensions</span>
    <span class="n">mu</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_1d</span><span class="p">(</span><span class="n">mu</span><span class="p">)</span>
    <span class="n">COV</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_2d</span><span class="p">(</span><span class="n">COV</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">mu</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="p">():</span>
        <span class="n">mu</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">([</span><span class="n">mu</span><span class="p">])</span>
        <span class="n">COV</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">([</span><span class="n">COV</span><span class="p">])</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">COV</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">COV</span><span class="p">)</span>

    <span class="n">sig</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="n">COV</span><span class="p">))</span>
    <span class="n">corr</span> <span class="o">=</span> <span class="n">COV</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">outer</span><span class="p">(</span><span class="n">sig</span><span class="p">,</span> <span class="n">sig</span><span class="p">)</span>

    <span class="n">ndim</span> <span class="o">=</span> <span class="n">mu</span><span class="o">.</span><span class="n">size</span>

    <span class="k">if</span> <span class="n">lower</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">lower</span> <span class="o">=</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">ndim</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">lower</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_1d</span><span class="p">(</span><span class="n">lower</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">upper</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">upper</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">ndim</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">upper</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_1d</span><span class="p">(</span><span class="n">upper</span><span class="p">)</span>

    <span class="c1"># replace None with np.inf</span>
    <span class="n">lower</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">lower</span> <span class="o">==</span> <span class="kc">None</span><span class="p">)[</span><span class="mi">0</span><span class="p">]]</span> <span class="o">=</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">inf</span>
    <span class="n">lower</span> <span class="o">=</span> <span class="n">lower</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
    <span class="n">upper</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">upper</span> <span class="o">==</span> <span class="kc">None</span><span class="p">)[</span><span class="mi">0</span><span class="p">]]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span>
    <span class="n">upper</span> <span class="o">=</span> <span class="n">upper</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>

    <span class="c1"># standardize the truncation limits</span>
    <span class="n">lower</span> <span class="o">=</span> <span class="p">(</span><span class="n">lower</span> <span class="o">-</span> <span class="n">mu</span><span class="p">)</span> <span class="o">/</span> <span class="n">sig</span>
    <span class="n">upper</span> <span class="o">=</span> <span class="p">(</span><span class="n">upper</span> <span class="o">-</span> <span class="n">mu</span><span class="p">)</span> <span class="o">/</span> <span class="n">sig</span>

    <span class="c1"># prepare the flags for infinite bounds (these are needed for the mvndst</span>
    <span class="c1"># function)</span>
    <span class="n">lowinf</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">isneginf</span><span class="p">(</span><span class="n">lower</span><span class="p">)</span>
    <span class="n">uppinf</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">isposinf</span><span class="p">(</span><span class="n">upper</span><span class="p">)</span>
    <span class="n">infin</span> <span class="o">=</span> <span class="mf">2.0</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">ndim</span><span class="p">)</span>

    <span class="n">np</span><span class="o">.</span><span class="n">putmask</span><span class="p">(</span><span class="n">infin</span><span class="p">,</span> <span class="n">lowinf</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
    <span class="n">np</span><span class="o">.</span><span class="n">putmask</span><span class="p">(</span><span class="n">infin</span><span class="p">,</span> <span class="n">uppinf</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
    <span class="n">np</span><span class="o">.</span><span class="n">putmask</span><span class="p">(</span><span class="n">infin</span><span class="p">,</span> <span class="n">lowinf</span> <span class="o">*</span> <span class="n">uppinf</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>

    <span class="c1"># prepare the correlation coefficients</span>
    <span class="k">if</span> <span class="n">ndim</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">correl</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">correl</span> <span class="o">=</span> <span class="n">corr</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">tril_indices</span><span class="p">(</span><span class="n">ndim</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)]</span>

    <span class="c1"># estimate the density</span>
    <span class="n">eps_alpha</span><span class="p">,</span> <span class="n">alpha</span><span class="p">,</span> <span class="n">__</span> <span class="o">=</span> <span class="n">mvndst</span><span class="p">(</span><span class="n">lower</span><span class="p">,</span> <span class="n">upper</span><span class="p">,</span> <span class="n">infin</span><span class="p">,</span> <span class="n">correl</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">alpha</span><span class="p">,</span> <span class="n">eps_alpha</span></div>


<span class="k">def</span> <span class="nf">get_theta</span><span class="p">(</span><span class="n">params</span><span class="p">,</span> <span class="n">inits</span><span class="p">,</span> <span class="n">distribution</span><span class="p">):</span>

    <span class="n">theta</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">inits</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>

    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="p">(</span><span class="n">params_i</span><span class="p">,</span> <span class="n">inits_i</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">params</span><span class="p">,</span> <span class="n">inits</span><span class="p">)):</span>

        <span class="k">if</span> <span class="n">distribution</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;normal&#39;</span><span class="p">,</span> <span class="s1">&#39;lognormal&#39;</span><span class="p">]:</span>
            <span class="n">sig</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">inits_i</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="o">+</span> <span class="n">params_i</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
            <span class="n">mu</span> <span class="o">=</span> <span class="n">inits_i</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">params_i</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">sig</span>
            <span class="n">theta</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">mu</span>
            <span class="n">theta</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">sig</span>

    <span class="k">return</span> <span class="n">theta</span>


<span class="k">def</span> <span class="nf">_get_limit_probs</span><span class="p">(</span><span class="n">limits</span><span class="p">,</span> <span class="n">distribution</span><span class="p">,</span> <span class="n">theta</span><span class="p">):</span>

    <span class="k">if</span> <span class="n">distribution</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;normal&#39;</span><span class="p">,</span> <span class="s1">&#39;lognormal&#39;</span><span class="p">]:</span>

        <span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="n">limits</span>
        <span class="n">mu</span> <span class="o">=</span> <span class="n">theta</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">sig</span> <span class="o">=</span> <span class="n">theta</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>

        <span class="k">if</span> <span class="n">a</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">p_a</span> <span class="o">=</span> <span class="n">norm</span><span class="o">.</span><span class="n">cdf</span><span class="p">((</span><span class="n">a</span> <span class="o">-</span> <span class="n">mu</span><span class="p">)</span> <span class="o">/</span> <span class="n">sig</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">p_a</span> <span class="o">=</span> <span class="mf">0.0</span>

        <span class="k">if</span> <span class="n">b</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">p_b</span> <span class="o">=</span> <span class="n">norm</span><span class="o">.</span><span class="n">cdf</span><span class="p">((</span><span class="n">b</span> <span class="o">-</span> <span class="n">mu</span><span class="p">)</span> <span class="o">/</span> <span class="n">sig</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">p_b</span> <span class="o">=</span> <span class="mf">1.0</span>

    <span class="k">return</span> <span class="n">p_a</span><span class="p">,</span> <span class="n">p_b</span>


<span class="k">def</span> <span class="nf">_get_std_samples</span><span class="p">(</span><span class="n">samples</span><span class="p">,</span> <span class="n">theta</span><span class="p">,</span> <span class="n">tr_limits</span><span class="p">,</span> <span class="n">distribution</span><span class="p">):</span>

    <span class="n">ndims</span> <span class="o">=</span> <span class="n">samples</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

    <span class="n">std_samples</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">samples</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>

    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="p">(</span><span class="n">samples_i</span><span class="p">,</span> <span class="n">theta_i</span><span class="p">,</span> <span class="n">tr_lim_i</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span>
        <span class="nb">zip</span><span class="p">(</span><span class="n">samples</span><span class="p">,</span> <span class="n">theta</span><span class="p">,</span> <span class="n">tr_limits</span><span class="p">)):</span>
        <span class="k">if</span> <span class="n">distribution</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;normal&#39;</span><span class="p">,</span> <span class="s1">&#39;lognormal&#39;</span><span class="p">]:</span>
            <span class="c1"># consider truncation if needed</span>
            <span class="n">p_a</span><span class="p">,</span> <span class="n">p_b</span> <span class="o">=</span> <span class="n">_get_limit_probs</span><span class="p">(</span><span class="n">tr_lim_i</span><span class="p">,</span> <span class="n">distribution</span><span class="p">,</span> <span class="n">theta_i</span><span class="p">)</span>
            <span class="n">uni_samples</span> <span class="o">=</span> <span class="p">(</span><span class="n">norm</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">samples_i</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="n">theta_i</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
                                    <span class="n">scale</span><span class="o">=</span><span class="n">theta_i</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="o">-</span> <span class="n">p_a</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">p_b</span> <span class="o">-</span> <span class="n">p_a</span><span class="p">)</span>
            <span class="n">std_samples</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">norm</span><span class="o">.</span><span class="n">ppf</span><span class="p">(</span><span class="n">uni_samples</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="mf">0.</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="mf">1.</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">std_samples</span>


<span class="k">def</span> <span class="nf">_get_std_corr_matrix</span><span class="p">(</span><span class="n">std_samples</span><span class="p">):</span>

    <span class="n">n_dims</span><span class="p">,</span> <span class="n">n_samples</span> <span class="o">=</span> <span class="n">std_samples</span><span class="o">.</span><span class="n">shape</span>

    <span class="n">rho_hat</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">n_dims</span><span class="p">,</span> <span class="n">n_dims</span><span class="p">))</span>
    <span class="n">np</span><span class="o">.</span><span class="n">fill_diagonal</span><span class="p">(</span><span class="n">rho_hat</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">dim_i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_dims</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">dim_j</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">dim_i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">n_dims</span><span class="p">):</span>
            <span class="n">rho_hat</span><span class="p">[</span><span class="n">dim_i</span><span class="p">,</span> <span class="n">dim_j</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span>
                <span class="n">std_samples</span><span class="p">[</span><span class="n">dim_i</span><span class="p">]</span> <span class="o">*</span> <span class="n">std_samples</span><span class="p">[</span><span class="n">dim_j</span><span class="p">])</span> <span class="o">/</span> <span class="n">n_samples</span>
            <span class="n">rho_hat</span><span class="p">[</span><span class="n">dim_j</span><span class="p">,</span> <span class="n">dim_i</span><span class="p">]</span> <span class="o">=</span> <span class="n">rho_hat</span><span class="p">[</span><span class="n">dim_i</span><span class="p">,</span> <span class="n">dim_j</span><span class="p">]</span>

    <span class="c1"># make sure rho_hat is positive semidefinite</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">L</span> <span class="o">=</span> <span class="n">cholesky</span><span class="p">(</span><span class="n">rho_hat</span><span class="p">,</span> <span class="n">lower</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>  <span class="c1"># if this works, we&#39;re good</span>

    <span class="k">except</span><span class="p">:</span>  <span class="c1"># otherwise, we can try to fix the matrix using SVD</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="n">U</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">V</span> <span class="o">=</span> <span class="n">svd</span><span class="p">(</span><span class="n">rho_hat</span><span class="p">,</span> <span class="p">)</span>
        <span class="k">except</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span>

        <span class="n">S</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diagflat</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>

        <span class="n">rho_hat</span> <span class="o">=</span> <span class="n">U</span> <span class="o">@</span> <span class="n">S</span> <span class="o">@</span> <span class="n">U</span><span class="o">.</span><span class="n">T</span>
        <span class="n">np</span><span class="o">.</span><span class="n">fill_diagonal</span><span class="p">(</span><span class="n">rho_hat</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">)</span>

        <span class="k">if</span> <span class="p">((</span><span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">rho_hat</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mf">1.0</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">rho_hat</span><span class="p">)</span> <span class="o">&lt;</span> <span class="o">-</span><span class="mf">1.0</span><span class="p">)):</span>
            <span class="k">return</span> <span class="kc">None</span>

    <span class="k">return</span> <span class="n">rho_hat</span>


<span class="k">def</span> <span class="nf">_mvn_scale</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">rho</span><span class="p">):</span>

    <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_2d</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
    <span class="n">n_dims</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>

    <span class="n">rho_0</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">n_dims</span><span class="p">,</span> <span class="n">n_dims</span><span class="p">))</span>
    <span class="n">np</span><span class="o">.</span><span class="n">fill_diagonal</span><span class="p">(</span><span class="n">rho_0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
    <span class="n">a</span> <span class="o">=</span> <span class="n">mvn</span><span class="o">.</span><span class="n">pdf</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">mean</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">n_dims</span><span class="p">),</span> <span class="n">cov</span><span class="o">=</span><span class="n">rho_0</span><span class="p">)</span>

    <span class="n">b</span> <span class="o">=</span> <span class="n">mvn</span><span class="o">.</span><span class="n">pdf</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">mean</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">n_dims</span><span class="p">),</span> <span class="n">cov</span><span class="o">=</span><span class="n">rho</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">b</span> <span class="o">/</span> <span class="n">a</span>


<span class="k">def</span> <span class="nf">_neg_log_likelihood</span><span class="p">(</span><span class="n">params</span><span class="p">,</span> <span class="n">inits</span><span class="p">,</span> <span class="n">bnd_lower</span><span class="p">,</span> <span class="n">bnd_upper</span><span class="p">,</span> <span class="n">samples</span><span class="p">,</span>
                        <span class="n">distribution</span><span class="p">,</span> <span class="n">tr_limits</span><span class="p">,</span> <span class="n">det_limits</span><span class="p">,</span> <span class="n">censored_count</span><span class="p">,</span>
                        <span class="n">enforce_bounds</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>

    <span class="c1"># First, check if the parameters are within the pre-defined bounds</span>
    <span class="k">if</span> <span class="n">enforce_bounds</span><span class="p">:</span>
        <span class="k">if</span> <span class="p">((</span><span class="n">params</span> <span class="o">&gt;</span> <span class="n">bnd_lower</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">params</span> <span class="o">&lt;</span> <span class="n">bnd_upper</span><span class="p">))</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="o">==</span> <span class="kc">False</span><span class="p">:</span>
            <span class="c1"># if they are not, then return a large value to discourage the</span>
            <span class="c1"># optimization algorithm from going in that direction</span>
            <span class="k">return</span> <span class="mf">1e10</span>

    <span class="c1"># If there is nan in params, return a large value</span>
    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">params</span><span class="p">)):</span>
        <span class="k">return</span> <span class="mf">1e10</span>

    <span class="n">params</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">params</span><span class="p">,</span> <span class="n">inits</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
    <span class="n">n_dims</span><span class="p">,</span> <span class="n">n_samples</span> <span class="o">=</span> <span class="n">samples</span><span class="o">.</span><span class="n">shape</span>

    <span class="n">theta</span> <span class="o">=</span> <span class="n">get_theta</span><span class="p">(</span><span class="n">params</span><span class="p">,</span> <span class="n">inits</span><span class="p">,</span> <span class="n">distribution</span><span class="p">)</span>

    <span class="n">likelihoods</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">samples</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>

    <span class="c1"># calculate the marginal likelihoods</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="p">(</span><span class="n">theta_i</span><span class="p">,</span> <span class="n">samples_i</span><span class="p">,</span> <span class="n">tr_lim_i</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span>
        <span class="nb">zip</span><span class="p">(</span><span class="n">theta</span><span class="p">,</span> <span class="n">samples</span><span class="p">,</span> <span class="n">tr_limits</span><span class="p">)):</span>

        <span class="c1"># consider truncation if needed</span>
        <span class="n">p_a</span><span class="p">,</span> <span class="n">p_b</span> <span class="o">=</span> <span class="n">_get_limit_probs</span><span class="p">(</span><span class="n">tr_lim_i</span><span class="p">,</span> <span class="n">distribution</span><span class="p">,</span> <span class="n">theta_i</span><span class="p">)</span>
        <span class="n">tr_alpha</span> <span class="o">=</span> <span class="n">p_b</span> <span class="o">-</span> <span class="n">p_a</span>  <span class="c1"># this is the probability mass within the</span>
        <span class="c1"># truncation limits</span>

        <span class="c1"># calculate the likelihood for each available sample</span>
        <span class="k">if</span> <span class="n">distribution</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;normal&#39;</span><span class="p">,</span> <span class="s1">&#39;lognormal&#39;</span><span class="p">]:</span>
            <span class="n">likelihoods</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">norm</span><span class="o">.</span><span class="n">pdf</span><span class="p">(</span><span class="n">samples_i</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="n">theta_i</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
                                      <span class="n">scale</span><span class="o">=</span><span class="n">theta_i</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="o">/</span> <span class="n">tr_alpha</span>

    <span class="c1"># transform every sample into standard normal space and get the correlation</span>
    <span class="c1"># matrix</span>
    <span class="n">std_samples</span> <span class="o">=</span> <span class="n">_get_std_samples</span><span class="p">(</span><span class="n">samples</span><span class="p">,</span> <span class="n">theta</span><span class="p">,</span> <span class="n">tr_limits</span><span class="p">,</span> <span class="n">distribution</span><span class="p">)</span>
    <span class="n">rho_hat</span> <span class="o">=</span> <span class="n">_get_std_corr_matrix</span><span class="p">(</span><span class="n">std_samples</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">rho_hat</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">return</span> <span class="mf">1e10</span>

    <span class="c1"># likelihoods related to censoring need to be handled together</span>
    <span class="k">if</span> <span class="n">censored_count</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>

        <span class="n">det_lower</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">n_dims</span><span class="p">)</span>
        <span class="n">det_upper</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">n_dims</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="p">(</span><span class="n">theta_i</span><span class="p">,</span> <span class="n">tr_lim_i</span><span class="p">,</span> <span class="n">det_lim_i</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span>
            <span class="nb">zip</span><span class="p">(</span><span class="n">theta</span><span class="p">,</span> <span class="n">tr_limits</span><span class="p">,</span> <span class="n">det_limits</span><span class="p">)):</span>
            <span class="c1"># also prepare the standardized detection limits</span>
            <span class="n">p_a</span><span class="p">,</span> <span class="n">p_b</span> <span class="o">=</span> <span class="n">_get_limit_probs</span><span class="p">(</span><span class="n">tr_lim_i</span><span class="p">,</span> <span class="n">distribution</span><span class="p">,</span> <span class="n">theta_i</span><span class="p">)</span>
            <span class="n">p_l</span><span class="p">,</span> <span class="n">p_u</span> <span class="o">=</span> <span class="n">_get_limit_probs</span><span class="p">(</span><span class="n">det_lim_i</span><span class="p">,</span> <span class="n">distribution</span><span class="p">,</span> <span class="n">theta_i</span><span class="p">)</span>

            <span class="c1"># rescale to consider truncation</span>
            <span class="n">p_l</span><span class="p">,</span> <span class="n">p_u</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">([</span><span class="n">lim</span><span class="p">,</span> <span class="n">p_a</span><span class="p">]),</span> <span class="n">p_b</span><span class="p">])</span> <span class="k">for</span> <span class="n">lim</span> <span class="ow">in</span> <span class="p">[</span><span class="n">p_l</span><span class="p">,</span> <span class="n">p_u</span><span class="p">]]</span>
            <span class="n">p_l</span><span class="p">,</span> <span class="n">p_u</span> <span class="o">=</span> <span class="p">[(</span><span class="n">lim</span> <span class="o">-</span> <span class="n">p_a</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">p_b</span> <span class="o">-</span> <span class="n">p_a</span><span class="p">)</span> <span class="k">for</span> <span class="n">lim</span> <span class="ow">in</span> <span class="p">[</span><span class="n">p_l</span><span class="p">,</span> <span class="n">p_u</span><span class="p">]]</span>

            <span class="n">det_lower</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">det_upper</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">norm</span><span class="o">.</span><span class="n">ppf</span><span class="p">([</span><span class="n">p_l</span><span class="p">,</span> <span class="n">p_u</span><span class="p">],</span> <span class="n">loc</span><span class="o">=</span><span class="mf">0.</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="mf">1.</span><span class="p">)</span>

        <span class="c1"># get the likelihood of censoring a sample</span>
        <span class="n">det_alpha</span><span class="p">,</span> <span class="n">eps_alpha</span> <span class="o">=</span> <span class="n">mvn_orthotope_density</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">n_dims</span><span class="p">),</span> <span class="n">rho_hat</span><span class="p">,</span>
                                                     <span class="n">det_lower</span><span class="p">,</span> <span class="n">det_upper</span><span class="p">)</span>

        <span class="c1"># Make sure that det_alpha is estimated with sufficient accuracy</span>
        <span class="k">if</span> <span class="n">det_alpha</span> <span class="o">&lt;=</span> <span class="mf">100.</span> <span class="o">*</span> <span class="n">eps_alpha</span><span class="p">:</span>
            <span class="k">return</span> <span class="mf">1e10</span>

        <span class="c1"># make sure that the likelihood is a positive number</span>
        <span class="n">cen_likelihood</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="mf">1.0</span> <span class="o">-</span> <span class="n">det_alpha</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nextafter</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>

    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># If the data is not censored, use 1.0 for cen_likelihood to get a</span>
        <span class="c1"># zero log-likelihood later. Note that although this is</span>
        <span class="c1"># theoretically not correct, it does not alter the solution and</span>
        <span class="c1"># it is numerically much more convenient than working around the</span>
        <span class="c1"># log of zero likelihood.</span>
        <span class="n">cen_likelihood</span> <span class="o">=</span> <span class="mf">1.0</span>

    <span class="c1"># flatten the likelihoods calculated in each dimension</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">scale</span> <span class="o">=</span> <span class="n">_mvn_scale</span><span class="p">(</span><span class="n">std_samples</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">rho_hat</span><span class="p">)</span>
    <span class="k">except</span><span class="p">:</span>
        <span class="k">return</span> <span class="mf">1e10</span>
    <span class="n">likelihoods</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">prod</span><span class="p">(</span><span class="n">likelihoods</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span> <span class="o">*</span> <span class="n">scale</span>

    <span class="c1"># Zeros are a result of limited floating point precision. Replace them</span>
    <span class="c1"># with the smallest possible positive floating point number to</span>
    <span class="c1"># improve convergence.</span>
    <span class="n">likelihoods</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">clip</span><span class="p">(</span><span class="n">likelihoods</span><span class="p">,</span> <span class="n">a_min</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">nextafter</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="n">a_max</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>

    <span class="c1"># calculate the total negative log likelihood</span>
    <span class="n">NLL</span> <span class="o">=</span> <span class="o">-</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">likelihoods</span><span class="p">))</span>  <span class="c1"># from samples</span>
            <span class="o">+</span> <span class="n">censored_count</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">cen_likelihood</span><span class="p">))</span>  <span class="c1"># censoring influence</span>

    <span class="c1"># normalize the NLL with the sample count</span>
    <span class="n">NLL</span> <span class="o">=</span> <span class="n">NLL</span> <span class="o">/</span> <span class="n">samples</span><span class="o">.</span><span class="n">size</span>

    <span class="c1"># print(theta[0], NLL)</span>

    <span class="k">return</span> <span class="n">NLL</span>

<div class="viewcode-block" id="fit_distribution"><a class="viewcode-back" href="../../common/developer_manual/API/pelicun/API_pelicun_uq.html#pelicun.uq.fit_distribution">[docs]</a><span class="k">def</span> <span class="nf">fit_distribution</span><span class="p">(</span><span class="n">raw_samples</span><span class="p">,</span> <span class="n">distribution</span><span class="p">,</span> <span class="n">truncation_limits</span><span class="o">=</span><span class="p">[</span><span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">],</span>
                     <span class="n">censored_count</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">detection_limits</span><span class="o">=</span><span class="p">[</span><span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">],</span>
                     <span class="n">multi_fit</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">alpha_lim</span><span class="o">=</span><span class="mf">1e-4</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Fit a distribution to samples using maximum likelihood estimation.</span>

<span class="sd">    The number of dimensions of the distribution are inferred from the</span>
<span class="sd">    shape of the sample data. Censoring is automatically considered if the</span>
<span class="sd">    number of censored samples and the corresponding detection limits are</span>
<span class="sd">    provided. Infinite or unspecified truncation limits lead to fitting a</span>
<span class="sd">    non-truncated distribution in that dimension.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    raw_samples: float ndarray</span>
<span class="sd">        Raw data that serves as the basis of estimation. The number of samples</span>
<span class="sd">        equals the number of columns and each row introduces a new feature. In</span>
<span class="sd">        other words: a list of sample lists is expected where each sample list</span>
<span class="sd">        is a collection of samples of one variable.</span>
<span class="sd">    distribution: {&#39;normal&#39;, &#39;lognormal&#39;}</span>
<span class="sd">        Defines the target probability distribution type. Different types of</span>
<span class="sd">        distributions can be mixed by providing a list rather than a single</span>
<span class="sd">        value. Each element of the list corresponds to one of the features in</span>
<span class="sd">        the raw_samples.</span>
<span class="sd">    truncation_limits: float ndarray, optional, default: [None, None]</span>
<span class="sd">        Lower and/or upper truncation limits for the specified distributions.</span>
<span class="sd">        A two-element vector can be used for a univariate case, while two lists</span>
<span class="sd">        of limits are expected in multivariate cases. If the distribution is</span>
<span class="sd">        non-truncated from one side in a subset of the dimensions, use either</span>
<span class="sd">        `None` or assign an infinite value (i.e. numpy.inf) to those dimensions.</span>
<span class="sd">    censored_count: int, optional, default: None</span>
<span class="sd">        The number of censored samples that are beyond the detection limits.</span>
<span class="sd">        All samples outside the detection limits are aggregated into one set.</span>
<span class="sd">        This works the same way in one and in multiple dimensions. Prescription</span>
<span class="sd">        of specific censored sample counts for sub-regions of the input space</span>
<span class="sd">        outside the detection limits is not supported.</span>
<span class="sd">    detection_limits: float ndarray, optional, default: [None, None]</span>
<span class="sd">        Lower and/or upper detection limits for the provided samples. A</span>
<span class="sd">        two-element vector can be used for a univariate case, while two lists</span>
<span class="sd">        of limits are expected in multivariate cases. If the data is not</span>
<span class="sd">        censored from one side in a subset of the dimensions, use either `None`</span>
<span class="sd">        or assign an infinite value (i.e. numpy.inf) to those dimensions.</span>
<span class="sd">    multi_fit: bool, optional, default: False</span>
<span class="sd">        If True, we attempt to fit a multivariate distribution to the samples.</span>
<span class="sd">        Otherwise, we fit each marginal univariate distribution independently</span>
<span class="sd">        and estimate the correlation matrix in the end based on the fitted</span>
<span class="sd">        marginals. Using multi_fit can be advantageous with censored data and</span>
<span class="sd">        if the correlation in the data is not Gaussian. It leads to</span>
<span class="sd">        substantially longer calculation time and does not always produce</span>
<span class="sd">        better results, especially when the number of dimensions is large.</span>
<span class="sd">    alpha_lim: float, optional, default:None</span>
<span class="sd">        Introduces a lower limit to the probability density within the</span>
<span class="sd">        n-orthotope defined by the truncation limits. Assigning a reasonable</span>
<span class="sd">        minimum (such as 1e-4) can be useful when the mean of the distribution</span>
<span class="sd">        is several standard deviations from the truncation limits and the</span>
<span class="sd">        sample size is small. Such cases without a limit often converge to</span>
<span class="sd">        distant means with inflated variances. Besides being incorrect</span>
<span class="sd">        estimates, those solutions only offer negligible reduction in the</span>
<span class="sd">        negative log likelihood, while making subsequent sampling of the</span>
<span class="sd">        truncated normal distribution very challenging.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    theta: float ndarray</span>
<span class="sd">        Estimates of the parameters of the fitted probability distribution in</span>
<span class="sd">        each dimension. The following parameters are returned for the supported</span>
<span class="sd">        distributions:</span>
<span class="sd">        normal - mean, standard deviation;</span>
<span class="sd">        lognormal - median, log standard deviation;</span>
<span class="sd">    Rho: float 2D ndarray, optional</span>
<span class="sd">        In the multivariate case, returns the estimate of the correlation</span>
<span class="sd">        matrix.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">samples</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_2d</span><span class="p">(</span><span class="n">raw_samples</span><span class="p">)</span>
    <span class="n">tr_limits</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_2d</span><span class="p">(</span><span class="n">truncation_limits</span><span class="p">)</span>
    <span class="n">det_limits</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_2d</span><span class="p">(</span><span class="n">detection_limits</span><span class="p">)</span>
    <span class="n">n_dims</span><span class="p">,</span> <span class="n">n_samples</span> <span class="o">=</span> <span class="n">samples</span><span class="o">.</span><span class="n">shape</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">tr_limits</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">samples</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">):</span>
        <span class="n">tr_limits</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">tile</span><span class="p">(</span><span class="n">tr_limits</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">samples</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                            <span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">([</span><span class="n">samples</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">2</span><span class="p">])</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">det_limits</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">samples</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">):</span>
        <span class="n">det_limits</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">tile</span><span class="p">(</span><span class="n">det_limits</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">samples</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                             <span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">([</span><span class="n">samples</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">2</span><span class="p">])</span>

    <span class="c1"># Convert samples to log space if the distribution is lognormal</span>
    <span class="k">if</span> <span class="n">distribution</span> <span class="o">==</span> <span class="s1">&#39;lognormal&#39;</span><span class="p">:</span>
        <span class="n">samples</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">samples</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">dim</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">tr_limits</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
            <span class="k">for</span> <span class="n">var</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">tr_limits</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]):</span>
                <span class="k">if</span> <span class="n">tr_limits</span><span class="p">[</span><span class="n">dim</span><span class="p">][</span><span class="n">var</span><span class="p">]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">tr_limits</span><span class="p">[</span><span class="n">dim</span><span class="p">][</span><span class="n">var</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">tr_limits</span><span class="p">[</span><span class="n">dim</span><span class="p">][</span><span class="n">var</span><span class="p">])</span>
        <span class="k">for</span> <span class="n">dim</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">det_limits</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
            <span class="k">for</span> <span class="n">var</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">det_limits</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]):</span>
                <span class="k">if</span> <span class="n">det_limits</span><span class="p">[</span><span class="n">dim</span><span class="p">][</span><span class="n">var</span><span class="p">]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">det_limits</span><span class="p">[</span><span class="n">dim</span><span class="p">][</span><span class="n">var</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">det_limits</span><span class="p">[</span><span class="n">dim</span><span class="p">][</span><span class="n">var</span><span class="p">])</span>


    <span class="c1"># Define initial values of distribution parameters</span>
    <span class="k">if</span> <span class="n">distribution</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;normal&#39;</span><span class="p">,</span> <span class="s1">&#39;lognormal&#39;</span><span class="p">]:</span>
        <span class="c1"># use the first two moments for normal distribution</span>
        <span class="n">mu_init</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">samples</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

        <span class="c1"># replace zero standard dev with negligible standard dev</span>
        <span class="n">sig_init</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="n">samples</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">sig_zero_id</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">sig_init</span> <span class="o">==</span> <span class="mf">0.0</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">sig_init</span><span class="p">[</span><span class="n">sig_zero_id</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1e-6</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">mu_init</span><span class="p">[</span><span class="n">sig_zero_id</span><span class="p">])</span>

        <span class="c1"># prepare a vector of initial values</span>
        <span class="c1"># Note: The actual optimization uses zeros as initial parameters to</span>
        <span class="c1"># avoid bias from different scales. These initial values are sent to</span>
        <span class="c1"># the likelihood function and considered in there.</span>
        <span class="n">inits</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">transpose</span><span class="p">([</span><span class="n">mu_init</span><span class="p">,</span> <span class="n">sig_init</span><span class="p">])</span>

        <span class="c1"># Define the bounds for each input (assuming standardized initials)</span>
        <span class="c1"># These bounds help avoid unrealistic results and improve the</span>
        <span class="c1"># convergence rate</span>
        <span class="n">bnd_lower</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="o">-</span><span class="mf">10.0</span><span class="p">,</span> <span class="o">-</span><span class="mf">5.0</span><span class="p">]</span> <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_dims</span><span class="p">)])</span>
        <span class="n">bnd_upper</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mf">10.0</span><span class="p">,</span> <span class="mf">5.0</span><span class="p">]</span> <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_dims</span><span class="p">)])</span>

    <span class="n">bnd_lower</span> <span class="o">=</span> <span class="n">bnd_lower</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>
    <span class="n">bnd_upper</span> <span class="o">=</span> <span class="n">bnd_upper</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>

    <span class="c1">#inits_0 = np.copy(inits)</span>

    <span class="c1"># There is nothing to gain from a time-consuming optimization if..</span>
    <span class="c1">#     the number of samples is too small</span>
    <span class="k">if</span> <span class="p">((</span><span class="n">n_samples</span> <span class="o">&lt;</span> <span class="mi">3</span><span class="p">)</span> <span class="ow">or</span>
        <span class="c1"># there are no truncation or detection limits involved</span>
        <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">tr_limits</span> <span class="o">==</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">and</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">det_limits</span> <span class="o">==</span> <span class="kc">None</span><span class="p">))):</span>

        <span class="c1"># In this case, it is typically hard to improve on the method of</span>
        <span class="c1"># moments estimates for the parameters of the marginal distributions</span>
        <span class="n">theta</span> <span class="o">=</span> <span class="n">inits</span>

    <span class="c1"># Otherwise, we run the optimization that aims to find the parameters that</span>
    <span class="c1"># maximize the likelihood of observing the samples</span>
    <span class="k">else</span><span class="p">:</span>

        <span class="c1"># First, optimize for each marginal independently</span>
        <span class="k">for</span> <span class="n">dim</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_dims</span><span class="p">):</span>

            <span class="n">inits_i</span> <span class="o">=</span> <span class="n">inits</span><span class="p">[</span><span class="n">dim</span><span class="p">:</span><span class="n">dim</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span>

            <span class="n">tr_limits_i</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">]</span>
            <span class="k">for</span> <span class="n">lim</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">2</span><span class="p">):</span>
                <span class="k">if</span> <span class="p">((</span><span class="n">tr_limits</span><span class="p">[</span><span class="n">dim</span><span class="p">][</span><span class="n">lim</span><span class="p">]</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">and</span>
                    <span class="p">(</span><span class="n">det_limits</span><span class="p">[</span><span class="n">dim</span><span class="p">][</span><span class="n">lim</span><span class="p">]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">)):</span>
                    <span class="n">tr_limits_i</span><span class="p">[</span><span class="n">lim</span><span class="p">]</span> <span class="o">=</span> <span class="n">det_limits</span><span class="p">[</span><span class="n">dim</span><span class="p">][</span><span class="n">lim</span><span class="p">]</span>
                <span class="k">elif</span> <span class="n">det_limits</span><span class="p">[</span><span class="n">dim</span><span class="p">][</span><span class="n">lim</span><span class="p">]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">tr_limits_i</span><span class="p">[</span><span class="n">lim</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">([</span><span class="n">tr_limits</span><span class="p">[</span><span class="n">dim</span><span class="p">][</span><span class="n">lim</span><span class="p">],</span>
                                               <span class="n">det_limits</span><span class="p">[</span><span class="n">dim</span><span class="p">][</span><span class="n">lim</span><span class="p">]])</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">tr_limits_i</span><span class="p">[</span><span class="n">lim</span><span class="p">]</span> <span class="o">=</span> <span class="n">tr_limits</span><span class="p">[</span><span class="n">dim</span><span class="p">][</span><span class="n">lim</span><span class="p">]</span>

            <span class="n">out_m_i</span> <span class="o">=</span> <span class="n">minimize</span><span class="p">(</span><span class="n">_neg_log_likelihood</span><span class="p">,</span>
                               <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">inits</span><span class="p">[</span><span class="n">dim</span><span class="p">]</span><span class="o">.</span><span class="n">size</span><span class="p">),</span>
                               <span class="n">args</span><span class="o">=</span><span class="p">(</span><span class="n">inits_i</span><span class="p">,</span>
                                     <span class="n">bnd_lower</span><span class="p">[</span><span class="n">dim</span><span class="p">:</span><span class="n">dim</span> <span class="o">+</span> <span class="mi">1</span><span class="p">],</span>
                                     <span class="n">bnd_upper</span><span class="p">[</span><span class="n">dim</span><span class="p">:</span><span class="n">dim</span> <span class="o">+</span> <span class="mi">1</span><span class="p">],</span>
                                     <span class="n">samples</span><span class="p">[</span><span class="n">dim</span><span class="p">:</span><span class="n">dim</span> <span class="o">+</span> <span class="mi">1</span><span class="p">],</span>
                                     <span class="n">distribution</span><span class="p">,</span>
                                     <span class="p">[</span><span class="n">tr_limits_i</span><span class="p">,</span> <span class="p">],</span>
                                     <span class="p">[</span><span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">],</span>
                                     <span class="mi">0</span><span class="p">,</span> <span class="kc">True</span><span class="p">,),</span>
                               <span class="n">method</span><span class="o">=</span><span class="s1">&#39;BFGS&#39;</span><span class="p">,</span>
                               <span class="n">options</span><span class="o">=</span><span class="nb">dict</span><span class="p">(</span><span class="n">maxiter</span><span class="o">=</span><span class="mi">50</span><span class="p">)</span>
                               <span class="p">)</span>

            <span class="n">out</span> <span class="o">=</span> <span class="n">out_m_i</span><span class="o">.</span><span class="n">x</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">inits_i</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
            <span class="n">theta</span> <span class="o">=</span> <span class="n">get_theta</span><span class="p">(</span><span class="n">out</span><span class="p">,</span> <span class="n">inits_i</span><span class="p">,</span> <span class="n">distribution</span><span class="p">)</span>
            <span class="n">inits</span><span class="p">[</span><span class="n">dim</span><span class="p">]</span> <span class="o">=</span> <span class="n">theta</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

        <span class="c1"># Second, if requested, we attempt the multivariate fitting using the</span>
        <span class="c1"># marginal results as initial parameters.</span>
        <span class="k">if</span> <span class="n">multi_fit</span> <span class="ow">or</span> <span class="p">(</span><span class="n">censored_count</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">):</span>

            <span class="n">out_m</span> <span class="o">=</span> <span class="n">minimize</span><span class="p">(</span><span class="n">_neg_log_likelihood</span><span class="p">,</span>
                             <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">inits</span><span class="o">.</span><span class="n">size</span><span class="p">),</span>
                             <span class="n">args</span><span class="o">=</span><span class="p">(</span><span class="n">inits</span><span class="p">,</span> <span class="n">bnd_lower</span><span class="p">,</span> <span class="n">bnd_upper</span><span class="p">,</span> <span class="n">samples</span><span class="p">,</span>
                                   <span class="n">distribution</span><span class="p">,</span> <span class="n">tr_limits</span><span class="p">,</span> <span class="n">det_limits</span><span class="p">,</span>
                                   <span class="n">censored_count</span><span class="p">,</span> <span class="kc">True</span><span class="p">,),</span>
                             <span class="n">method</span><span class="o">=</span><span class="s1">&#39;BFGS&#39;</span><span class="p">,</span>
                             <span class="n">options</span><span class="o">=</span><span class="nb">dict</span><span class="p">(</span><span class="n">maxiter</span><span class="o">=</span><span class="mi">50</span><span class="p">)</span>
                             <span class="p">)</span>

            <span class="n">out</span> <span class="o">=</span> <span class="n">out_m</span><span class="o">.</span><span class="n">x</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">inits</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
            <span class="n">theta</span> <span class="o">=</span> <span class="n">get_theta</span><span class="p">(</span><span class="n">out</span><span class="p">,</span> <span class="n">inits</span><span class="p">,</span> <span class="n">distribution</span><span class="p">)</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="n">theta</span> <span class="o">=</span> <span class="n">inits</span>

    <span class="c1"># Calculate rho in the standard normal space because we will generate new</span>
    <span class="c1"># samples using that type of correlation (i.e., Gaussian copula)</span>
    <span class="n">std_samples</span> <span class="o">=</span> <span class="n">_get_std_samples</span><span class="p">(</span><span class="n">samples</span><span class="p">,</span> <span class="n">theta</span><span class="p">,</span> <span class="n">tr_limits</span><span class="p">,</span> <span class="n">distribution</span><span class="p">)</span>
    <span class="n">rho_hat</span> <span class="o">=</span> <span class="n">_get_std_corr_matrix</span><span class="p">(</span><span class="n">std_samples</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">rho_hat</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="c1"># If there is not enough data to produce a valid correlation matrix</span>
        <span class="c1"># estimate, we assume independence</span>
        <span class="c1"># TODO: provide a warning for the user</span>
        <span class="n">rho_hat</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">n_dims</span><span class="p">,</span> <span class="n">n_dims</span><span class="p">))</span>
        <span class="n">np</span><span class="o">.</span><span class="n">fill_diagonal</span><span class="p">(</span><span class="n">rho_hat</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">)</span>

    <span class="c1"># Convert mean back to linear space if the distribution is lognormal</span>
    <span class="k">if</span> <span class="n">distribution</span> <span class="o">==</span> <span class="s1">&#39;lognormal&#39;</span><span class="p">:</span>
        <span class="n">theta_mod</span> <span class="o">=</span> <span class="n">theta</span><span class="o">.</span><span class="n">T</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">theta_mod</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">theta_mod</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="n">theta</span> <span class="o">=</span> <span class="n">theta_mod</span><span class="o">.</span><span class="n">T</span>

    <span class="c1">#for val in list(zip(inits_0, theta)):</span>
    <span class="c1">#    print(val)</span>

    <span class="k">return</span> <span class="n">theta</span><span class="p">,</span> <span class="n">rho_hat</span></div>

<div class="viewcode-block" id="RandomVariable"><a class="viewcode-back" href="../../common/developer_manual/API/pelicun/API_pelicun_uq.html#pelicun.uq.RandomVariable">[docs]</a><span class="k">class</span> <span class="nc">RandomVariable</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Description</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    name: string</span>
<span class="sd">        A unique string that identifies the random variable.</span>
<span class="sd">    distribution: {&#39;normal&#39;, &#39;lognormal&#39;, &#39;multinomial&#39;, &#39;custom&#39;, &#39;empirical&#39;,</span>
<span class="sd">        &#39;coupled_empirical&#39;, &#39;uniform&#39;}, optional</span>
<span class="sd">        Defines the type of probability distribution for the random variable.</span>
<span class="sd">    theta: float scalar or ndarray, optional</span>
<span class="sd">        Set of parameters that define the cumulative distribution function of</span>
<span class="sd">        the variable given its distribution type. The following parameters are</span>
<span class="sd">        expected currently for the supported distribution types:</span>
<span class="sd">        normal - mean, standard deviation;</span>
<span class="sd">        lognormal - median, log standard deviation;</span>
<span class="sd">        uniform - a, b, the lower and upper bounds of the distribution;</span>
<span class="sd">        multinomial - likelihood of each unique event (the last event&#39;s</span>
<span class="sd">        likelihood is adjusted automatically to ensure the likelihoods sum up</span>
<span class="sd">        to one);</span>
<span class="sd">        custom - according to the custom expression provided;</span>
<span class="sd">        empirical and coupled_empirical - N/A.</span>
<span class="sd">    truncation_limits: float ndarray, optional</span>
<span class="sd">        Defines the [a,b] truncation limits for the distribution. Use None to</span>
<span class="sd">        assign no limit in one direction.</span>
<span class="sd">    bounded: float ndarray, optional</span>
<span class="sd">        Defines the [P_a, P_b] probability bounds for the distribution. Use None</span>
<span class="sd">        to assign no lower or upper bound.</span>
<span class="sd">    custom_expr: string, optional</span>
<span class="sd">        Provide an expression that is a Python syntax for a custom CDF. The</span>
<span class="sd">        controlling variable shall be &quot;x&quot; and the parameters shall be &quot;p1&quot;,</span>
<span class="sd">        &quot;p2&quot;, etc.</span>
<span class="sd">    anchor: RandomVariable, optional</span>
<span class="sd">        Anchors this to another variable. If the anchor is not None, this</span>
<span class="sd">        variable will be perfectly correlated with its anchor. Note that</span>
<span class="sd">        the attributes of this variable and its anchor do not have to be</span>
<span class="sd">        identical.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">distribution</span><span class="p">,</span> <span class="n">theta</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">truncation_limits</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">bounds</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">custom_expr</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">raw_samples</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">anchor</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">name</span>

        <span class="k">if</span> <span class="p">((</span><span class="n">distribution</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;empirical&#39;</span><span class="p">,</span> <span class="s1">&#39;coupled_empirical&#39;</span><span class="p">])</span> <span class="ow">and</span>
            <span class="p">(</span><span class="n">theta</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">)):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;A random variable that follows a </span><span class="si">{</span><span class="n">distribution</span><span class="si">}</span><span class="s2"> distribution &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;is characterized by a set of parameters (theta). The &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;parameters need to be provided when the RV is created.&quot;</span>
            <span class="p">)</span>

        <span class="k">if</span> <span class="n">distribution</span> <span class="o">==</span> <span class="s1">&#39;multinomial&#39;</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;The set of p values provided for a multinomial &quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;distribution shall sum up to less than or equal to 1.0. &quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;The provided values sum up to </span><span class="si">{</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span><span class="si">}</span><span class="s2">. p = &quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">theta</span><span class="si">}</span><span class="s2"> .&quot;</span>
                <span class="p">)</span>

        <span class="c1"># save the other parameters internally</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_distribution</span> <span class="o">=</span> <span class="n">distribution</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_theta</span> <span class="o">=</span> <span class="n">theta</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_truncation_limits</span> <span class="o">=</span> <span class="n">truncation_limits</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_bounds</span> <span class="o">=</span> <span class="n">bounds</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_custom_expr</span> <span class="o">=</span> <span class="n">custom_expr</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_raw_samples</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_1d</span><span class="p">(</span><span class="n">raw_samples</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_uni_samples</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_RV_set</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="n">anchor</span> <span class="o">==</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_anchor</span> <span class="o">=</span> <span class="bp">self</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_anchor</span> <span class="o">=</span> <span class="n">anchor</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">distribution</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the assigned probability distribution type.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_distribution</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">theta</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the assigned probability distribution parameters.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_theta</span>

    <span class="nd">@theta</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">theta</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Assign an anchor to the random variable</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_theta</span> <span class="o">=</span> <span class="n">value</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">truncation_limits</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the assigned truncation limits.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_truncation_limits</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">bounds</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the assigned probability bounds.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_bounds</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">custom_expr</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the assigned custom expression for CDF.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_custom_expr</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">RV_set</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the RV_set this RV is a member of</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_RV_set</span>

    <span class="nd">@RV_set</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">RV_set</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">         Assign an RV_set to this RV</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_RV_set</span> <span class="o">=</span> <span class="n">value</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">samples</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the empirical or generated samples.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_samples</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">samples_DF</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the empirical or generated samples in a pandas Series.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_samples_DF</span>

    <span class="nd">@samples</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">samples</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Assign samples to the random variable</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_samples</span> <span class="o">=</span> <span class="n">value</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_samples_DF</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">uni_samples</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the samples from the controlling uniform distribution.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_anchor</span><span class="o">.</span><span class="n">_uni_samples</span>

    <span class="nd">@uni_samples</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">uni_samples</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Assign the controlling samples to the random variable</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        value: float ndarray</span>
<span class="sd">            An array of floating point values in the [0, 1] domain.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_uni_samples</span> <span class="o">=</span> <span class="n">value</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">anchor</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the anchor of the variable (if any).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_anchor</span>

    <span class="nd">@anchor</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">anchor</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Assign an anchor to the random variable</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_anchor</span> <span class="o">=</span> <span class="n">value</span>

<div class="viewcode-block" id="RandomVariable.cdf"><a class="viewcode-back" href="../../common/developer_manual/API/pelicun/API_pelicun_uq.html#pelicun.uq.RandomVariable.cdf">[docs]</a>    <span class="k">def</span> <span class="nf">cdf</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">values</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the cdf at the given values</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">result</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">distribution</span> <span class="o">==</span> <span class="s1">&#39;normal&#39;</span><span class="p">:</span>
            <span class="n">mu</span><span class="p">,</span> <span class="n">sig</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">theta</span>

            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">truncation_limits</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">truncation_limits</span>

                <span class="k">if</span> <span class="n">a</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">a</span> <span class="o">=</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">inf</span>
                <span class="k">if</span> <span class="n">b</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">b</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span>

                <span class="n">p_a</span><span class="p">,</span> <span class="n">p_b</span> <span class="o">=</span> <span class="p">[</span><span class="n">norm</span><span class="o">.</span><span class="n">cdf</span><span class="p">((</span><span class="n">lim</span> <span class="o">-</span> <span class="n">mu</span><span class="p">)</span> <span class="o">/</span> <span class="n">sig</span><span class="p">)</span> <span class="k">for</span> <span class="n">lim</span> <span class="ow">in</span> <span class="p">[</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">]]</span>

                <span class="c1"># cap the values at the truncation limits</span>
                <span class="n">values</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">minimum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span><span class="n">values</span><span class="p">,</span> <span class="n">a</span><span class="p">),</span> <span class="n">b</span><span class="p">)</span>

                <span class="c1"># get the cdf from a non-truncated normal</span>
                <span class="n">p_vals</span> <span class="o">=</span> <span class="n">norm</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">values</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="n">mu</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">sig</span><span class="p">)</span>

                <span class="c1"># adjust for truncation</span>
                <span class="n">result</span> <span class="o">=</span> <span class="p">(</span><span class="n">p_vals</span> <span class="o">-</span> <span class="n">p_a</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">p_b</span> <span class="o">-</span> <span class="n">p_a</span><span class="p">)</span>

            <span class="k">else</span><span class="p">:</span>
                <span class="n">result</span> <span class="o">=</span> <span class="n">norm</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">values</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="n">mu</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">sig</span><span class="p">)</span>

        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">distribution</span> <span class="o">==</span> <span class="s1">&#39;lognormal&#39;</span><span class="p">:</span>
            <span class="n">theta</span><span class="p">,</span> <span class="n">beta</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">theta</span>

            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">truncation_limits</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">truncation_limits</span>

                <span class="k">if</span> <span class="n">a</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nextafter</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">b</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">b</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span>

                <span class="n">p_a</span><span class="p">,</span> <span class="n">p_b</span> <span class="o">=</span> <span class="p">[</span><span class="n">norm</span><span class="o">.</span><span class="n">cdf</span><span class="p">((</span><span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">lim</span><span class="p">)</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">theta</span><span class="p">))</span> <span class="o">/</span> <span class="n">beta</span><span class="p">)</span>
                            <span class="k">for</span> <span class="n">lim</span> <span class="ow">in</span> <span class="p">[</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">]]</span>

                <span class="c1"># cap the values at the truncation limits</span>
                <span class="n">values</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">minimum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span><span class="n">values</span><span class="p">,</span> <span class="n">a</span><span class="p">),</span> <span class="n">b</span><span class="p">)</span>

                <span class="c1"># get the cdf from a non-truncated lognormal</span>
                <span class="n">p_vals</span> <span class="o">=</span> <span class="n">norm</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">values</span><span class="p">),</span> <span class="n">loc</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">theta</span><span class="p">),</span> <span class="n">scale</span><span class="o">=</span><span class="n">beta</span><span class="p">)</span>

                <span class="c1"># adjust for truncation</span>
                <span class="n">result</span> <span class="o">=</span> <span class="p">(</span><span class="n">p_vals</span> <span class="o">-</span> <span class="n">p_a</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">p_b</span> <span class="o">-</span> <span class="n">p_a</span><span class="p">)</span>

            <span class="k">else</span><span class="p">:</span>
                <span class="n">values</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span><span class="n">values</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nextafter</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>

                <span class="n">result</span> <span class="o">=</span> <span class="n">norm</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">values</span><span class="p">),</span> <span class="n">loc</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">theta</span><span class="p">),</span> <span class="n">scale</span><span class="o">=</span><span class="n">beta</span><span class="p">)</span>

        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">distribution</span> <span class="o">==</span> <span class="s1">&#39;uniform&#39;</span><span class="p">:</span>
            <span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">theta</span>

            <span class="k">if</span> <span class="n">a</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">a</span> <span class="o">=</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">inf</span>
            <span class="k">if</span> <span class="n">b</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">b</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span>

            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">truncation_limits</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">truncation_limits</span>

            <span class="n">result</span> <span class="o">=</span> <span class="n">uniform</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">values</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="n">a</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">b</span><span class="o">-</span><span class="n">a</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">result</span></div>


<div class="viewcode-block" id="RandomVariable.inverse_transform"><a class="viewcode-back" href="../../common/developer_manual/API/pelicun/API_pelicun_uq.html#pelicun.uq.RandomVariable.inverse_transform">[docs]</a>    <span class="k">def</span> <span class="nf">inverse_transform</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">values</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Uses inverse probability integral transformation on the provided values.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">result</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">distribution</span> <span class="o">==</span> <span class="s1">&#39;normal&#39;</span><span class="p">:</span>
            <span class="n">mu</span><span class="p">,</span> <span class="n">sig</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">theta</span>

            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">truncation_limits</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">truncation_limits</span>

                <span class="k">if</span> <span class="n">a</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">a</span> <span class="o">=</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">inf</span>
                <span class="k">if</span> <span class="n">b</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">b</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span>

                <span class="n">p_a</span><span class="p">,</span> <span class="n">p_b</span> <span class="o">=</span> <span class="p">[</span><span class="n">norm</span><span class="o">.</span><span class="n">cdf</span><span class="p">((</span><span class="n">lim</span><span class="o">-</span><span class="n">mu</span><span class="p">)</span><span class="o">/</span><span class="n">sig</span><span class="p">)</span> <span class="k">for</span> <span class="n">lim</span> <span class="ow">in</span> <span class="p">[</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">]]</span>

                <span class="k">if</span> <span class="n">p_b</span> <span class="o">-</span> <span class="n">p_a</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                        <span class="s2">&quot;The probability mass within the truncation limits is &quot;</span>
                        <span class="s2">&quot;too small and the truncated distribution cannot be &quot;</span>
                        <span class="s2">&quot;sampled with sufficiently high accuracy. This is most &quot;</span>
                        <span class="s2">&quot;probably due to incorrect truncation limits set for &quot;</span>
                        <span class="s2">&quot;the distribution.&quot;</span>
                    <span class="p">)</span>

                <span class="n">result</span> <span class="o">=</span> <span class="n">norm</span><span class="o">.</span><span class="n">ppf</span><span class="p">(</span><span class="n">values</span> <span class="o">*</span> <span class="p">(</span><span class="n">p_b</span> <span class="o">-</span> <span class="n">p_a</span><span class="p">)</span> <span class="o">+</span> <span class="n">p_a</span><span class="p">,</span>
                                        <span class="n">loc</span><span class="o">=</span><span class="n">mu</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">sig</span><span class="p">)</span>

            <span class="k">else</span><span class="p">:</span>
                <span class="n">result</span> <span class="o">=</span> <span class="n">norm</span><span class="o">.</span><span class="n">ppf</span><span class="p">(</span><span class="n">values</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="n">mu</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">sig</span><span class="p">)</span>

        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">distribution</span> <span class="o">==</span> <span class="s1">&#39;lognormal&#39;</span><span class="p">:</span>
            <span class="n">theta</span><span class="p">,</span> <span class="n">beta</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">theta</span>

            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">truncation_limits</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">truncation_limits</span>

                <span class="k">if</span> <span class="n">a</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nextafter</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">nextafter</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="n">a</span><span class="p">)</span>

                <span class="k">if</span> <span class="n">b</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">b</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span>

                <span class="n">p_a</span><span class="p">,</span> <span class="n">p_b</span> <span class="o">=</span> <span class="p">[</span><span class="n">norm</span><span class="o">.</span><span class="n">cdf</span><span class="p">((</span><span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">lim</span><span class="p">)</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">theta</span><span class="p">))</span> <span class="o">/</span> <span class="n">beta</span><span class="p">)</span>
                            <span class="k">for</span> <span class="n">lim</span> <span class="ow">in</span> <span class="p">[</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">]]</span>

                <span class="n">result</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span>
                    <span class="n">norm</span><span class="o">.</span><span class="n">ppf</span><span class="p">(</span><span class="n">values</span> <span class="o">*</span> <span class="p">(</span><span class="n">p_b</span> <span class="o">-</span> <span class="n">p_a</span><span class="p">)</span> <span class="o">+</span> <span class="n">p_a</span><span class="p">,</span>
                             <span class="n">loc</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">theta</span><span class="p">),</span> <span class="n">scale</span><span class="o">=</span><span class="n">beta</span><span class="p">))</span>

            <span class="k">else</span><span class="p">:</span>
                <span class="n">result</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">norm</span><span class="o">.</span><span class="n">ppf</span><span class="p">(</span><span class="n">values</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">theta</span><span class="p">),</span> <span class="n">scale</span><span class="o">=</span><span class="n">beta</span><span class="p">))</span>

        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">distribution</span> <span class="o">==</span> <span class="s1">&#39;uniform&#39;</span><span class="p">:</span>
            <span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">theta</span>

            <span class="k">if</span> <span class="n">a</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">a</span> <span class="o">=</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">inf</span>
            <span class="k">if</span> <span class="n">b</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">b</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span>

            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">truncation_limits</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">truncation_limits</span>

            <span class="n">result</span> <span class="o">=</span> <span class="n">uniform</span><span class="o">.</span><span class="n">ppf</span><span class="p">(</span><span class="n">values</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="n">a</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">b</span><span class="o">-</span><span class="n">a</span><span class="p">)</span>

        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">distribution</span> <span class="o">==</span> <span class="s1">&#39;empirical&#39;</span><span class="p">:</span>

            <span class="n">s_ids</span> <span class="o">=</span> <span class="p">(</span><span class="n">values</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_raw_samples</span><span class="p">))</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
            <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_raw_samples</span><span class="p">[</span><span class="n">s_ids</span><span class="p">]</span>

        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">distribution</span> <span class="o">==</span> <span class="s1">&#39;coupled_empirical&#39;</span><span class="p">:</span>

            <span class="n">raw_sample_count</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_raw_samples</span><span class="p">)</span>
            <span class="n">new_sample_count</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">values</span><span class="p">)</span>
            <span class="n">new_samples</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">tile</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_raw_samples</span><span class="p">,</span>
                                  <span class="nb">int</span><span class="p">(</span><span class="n">new_sample_count</span><span class="o">/</span><span class="n">raw_sample_count</span><span class="p">)</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
            <span class="n">result</span> <span class="o">=</span> <span class="n">new_samples</span><span class="p">[:</span><span class="n">new_sample_count</span><span class="p">]</span>

        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">distribution</span> <span class="o">==</span> <span class="s1">&#39;multinomial&#39;</span><span class="p">:</span>

            <span class="n">p_cum</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cumsum</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">theta</span><span class="p">)[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

            <span class="n">samples</span> <span class="o">=</span> <span class="n">values</span>

            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">p_i</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">p_cum</span><span class="p">):</span>
                <span class="n">samples</span><span class="p">[</span><span class="n">samples</span> <span class="o">&lt;</span> <span class="n">p_i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">10</span> <span class="o">+</span> <span class="n">i</span>
            <span class="n">samples</span><span class="p">[</span><span class="n">samples</span> <span class="o">&lt;=</span> <span class="mf">1.0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">10</span> <span class="o">+</span> <span class="nb">len</span><span class="p">(</span><span class="n">p_cum</span><span class="p">)</span>

            <span class="n">result</span> <span class="o">=</span> <span class="n">samples</span> <span class="o">-</span> <span class="mi">10</span>

        <span class="k">return</span> <span class="n">result</span></div>

<div class="viewcode-block" id="RandomVariable.inverse_transform_sampling"><a class="viewcode-back" href="../../common/developer_manual/API/pelicun/API_pelicun_uq.html#pelicun.uq.RandomVariable.inverse_transform_sampling">[docs]</a>    <span class="k">def</span> <span class="nf">inverse_transform_sampling</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Creates samples using inverse probability integral transformation.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">samples</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">inverse_transform</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">uni_samples</span><span class="p">)</span></div></div>

<div class="viewcode-block" id="RandomVariableSet"><a class="viewcode-back" href="../../common/developer_manual/API/pelicun/API_pelicun_uq.html#pelicun.uq.RandomVariableSet">[docs]</a><span class="k">class</span> <span class="nc">RandomVariableSet</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Description</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    name: string</span>
<span class="sd">        A unique string that identifies the set of random variables.</span>
<span class="sd">    RV_list: list of RandomVariable</span>
<span class="sd">        Defines the random variables in the set</span>
<span class="sd">    Rho: float 2D ndarray</span>
<span class="sd">        Defines the correlation matrix that describes the correlation between</span>
<span class="sd">        the random variables in the set. Currently, only the Gaussian copula</span>
<span class="sd">        is supported.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">RV_list</span><span class="p">,</span> <span class="n">Rho</span><span class="p">):</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">name</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">RV_list</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>

            <span class="c1"># put the RVs in a dictionary for more efficient access</span>
            <span class="n">reorder</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">([</span><span class="n">RV</span><span class="o">.</span><span class="n">name</span> <span class="k">for</span> <span class="n">RV</span> <span class="ow">in</span> <span class="n">RV_list</span><span class="p">])</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_variables</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">([(</span><span class="n">RV_list</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">RV_list</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">reorder</span><span class="p">])</span>

            <span class="c1"># reorder the entries in the correlation matrix to correspond to the</span>
            <span class="c1"># sorted list of RVs</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_Rho</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">Rho</span><span class="p">[(</span><span class="n">reorder</span><span class="p">)]</span><span class="o">.</span><span class="n">T</span><span class="p">[(</span><span class="n">reorder</span><span class="p">)]</span><span class="o">.</span><span class="n">T</span><span class="p">)</span>

        <span class="k">else</span><span class="p">:</span> <span class="c1"># if there is only one variable (for testing, probably)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_variables</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">([(</span><span class="n">rv</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">rv</span><span class="p">)</span> <span class="k">for</span> <span class="n">rv</span> <span class="ow">in</span> <span class="n">RV_list</span><span class="p">])</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_Rho</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">Rho</span><span class="p">)</span>

        <span class="c1"># assign this RV_set to the variables</span>
        <span class="k">for</span> <span class="n">__</span><span class="p">,</span> <span class="n">var</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_variables</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">var</span><span class="o">.</span><span class="n">RV_set</span> <span class="o">=</span> <span class="bp">self</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">RV</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the random variable(s) assigned to the set</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_variables</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">size</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the size (i.e., number of variables in the) RV set</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_variables</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">samples</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the samples of the variables in the set</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">dict</span><span class="p">([(</span><span class="n">name</span><span class="p">,</span> <span class="n">rv</span><span class="o">.</span><span class="n">samples</span><span class="p">)</span> <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">rv</span>
                     <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_variables</span><span class="o">.</span><span class="n">items</span><span class="p">()])</span>

<div class="viewcode-block" id="RandomVariableSet.Rho"><a class="viewcode-back" href="../../common/developer_manual/API/pelicun/API_pelicun_uq.html#pelicun.uq.RandomVariableSet.Rho">[docs]</a>    <span class="k">def</span> <span class="nf">Rho</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">var_subset</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the (subset of the) correlation matrix.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">var_subset</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_Rho</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">var_ids</span> <span class="o">=</span> <span class="p">[</span><span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_variables</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">var_i</span><span class="p">)</span>
                       <span class="k">for</span> <span class="n">var_i</span> <span class="ow">in</span> <span class="n">var_subset</span><span class="p">]</span>
            <span class="k">return</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_Rho</span><span class="p">[</span><span class="n">var_ids</span><span class="p">])</span><span class="o">.</span><span class="n">T</span><span class="p">[</span><span class="n">var_ids</span><span class="p">]</span></div>

<div class="viewcode-block" id="RandomVariableSet.apply_correlation"><a class="viewcode-back" href="../../common/developer_manual/API/pelicun/API_pelicun_uq.html#pelicun.uq.RandomVariableSet.apply_correlation">[docs]</a>    <span class="k">def</span> <span class="nf">apply_correlation</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Apply correlation to n dimensional uniform samples.</span>

<span class="sd">        Currently, correlation is applied using a Gaussian copula. First, we</span>
<span class="sd">        try using Cholesky transformation. If the correlation matrix is not</span>
<span class="sd">        positive semidefinite and Cholesky fails, use SVD to apply the</span>
<span class="sd">        correlations while preserving as much as possible from the correlation</span>
<span class="sd">        matrix.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">U_RV</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">RV</span><span class="o">.</span><span class="n">uni_samples</span> <span class="k">for</span> <span class="n">RV_name</span><span class="p">,</span> <span class="n">RV</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">RV</span><span class="o">.</span><span class="n">items</span><span class="p">()])</span>

        <span class="c1"># First try doing the Cholesky transformation</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">N_RV</span> <span class="o">=</span> <span class="n">norm</span><span class="o">.</span><span class="n">ppf</span><span class="p">(</span><span class="n">U_RV</span><span class="p">)</span>

            <span class="n">L</span> <span class="o">=</span> <span class="n">cholesky</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_Rho</span><span class="p">,</span> <span class="n">lower</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

            <span class="n">NC_RV</span> <span class="o">=</span> <span class="n">L</span> <span class="o">@</span> <span class="n">N_RV</span>

            <span class="n">UC_RV</span> <span class="o">=</span> <span class="n">norm</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">NC_RV</span><span class="p">)</span>

        <span class="k">except</span><span class="p">:</span>

            <span class="c1"># if the Cholesky doesn&#39;t work, we need to use the more</span>
            <span class="c1"># time-consuming but more robust approach based on SVD</span>
            <span class="n">N_RV</span> <span class="o">=</span> <span class="n">norm</span><span class="o">.</span><span class="n">ppf</span><span class="p">(</span><span class="n">U_RV</span><span class="p">)</span>

            <span class="n">U</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">__</span> <span class="o">=</span> <span class="n">svd</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_Rho</span><span class="p">,</span> <span class="p">)</span>
            <span class="n">S</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diagflat</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">s</span><span class="p">))</span>

            <span class="n">NC_RV</span> <span class="o">=</span> <span class="p">(</span><span class="n">N_RV</span><span class="o">.</span><span class="n">T</span> <span class="o">@</span> <span class="n">S</span> <span class="o">@</span> <span class="n">U</span><span class="o">.</span><span class="n">T</span><span class="p">)</span><span class="o">.</span><span class="n">T</span>

            <span class="n">UC_RV</span> <span class="o">=</span> <span class="n">norm</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">NC_RV</span><span class="p">)</span>

        <span class="k">for</span> <span class="p">(</span><span class="n">RV_name</span><span class="p">,</span> <span class="n">RV</span><span class="p">),</span> <span class="n">uc_RV</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">RV</span><span class="o">.</span><span class="n">items</span><span class="p">(),</span> <span class="n">UC_RV</span><span class="p">):</span>
            <span class="n">RV</span><span class="o">.</span><span class="n">uni_samples</span> <span class="o">=</span> <span class="n">uc_RV</span></div>

<div class="viewcode-block" id="RandomVariableSet.orthotope_density"><a class="viewcode-back" href="../../common/developer_manual/API/pelicun/API_pelicun_uq.html#pelicun.uq.RandomVariableSet.orthotope_density">[docs]</a>    <span class="k">def</span> <span class="nf">orthotope_density</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">lower</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">upper</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">var_subset</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Estimate the probability density within an orthotope for the RV set.</span>

<span class="sd">        Use the mvn_orthotope_density function in this module for the</span>
<span class="sd">        calculation. The distribution of individual RVs is not limited to the</span>
<span class="sd">        normal family. The provided limits are converted to the standard normal</span>
<span class="sd">        space that is the basis of all RVs in pelicun. Truncation limits and</span>
<span class="sd">        correlation (using Gaussian copula) are automatically taken into</span>
<span class="sd">        consideration.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        lower: float ndarray, optional, default: None</span>
<span class="sd">            Lower bound(s) of the orthotope. A scalar value can be used for a</span>
<span class="sd">            univariate RV; a list of bounds is expected in multivariate cases.</span>
<span class="sd">            If the orthotope is not bounded from below in a dimension, use</span>
<span class="sd">            &#39;None&#39; to that dimension.</span>
<span class="sd">        upper: float ndarray, optional, default: None</span>
<span class="sd">            Upper bound(s) of the orthotope. A scalar value can be used for a</span>
<span class="sd">            univariate RV; a list of bounds is expected in multivariate cases.</span>
<span class="sd">            If the orthotope is not bounded from above in a dimension, use</span>
<span class="sd">            &#39;None&#39; to that dimension.</span>
<span class="sd">        var_subset: list of strings, optional, default: None</span>
<span class="sd">            If provided, allows for selecting only a subset of the variables in</span>
<span class="sd">            the RV_set for the density calculation.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        alpha: float</span>
<span class="sd">            Estimate of the probability density within the orthotope.</span>
<span class="sd">        eps_alpha: float</span>
<span class="sd">            Estimate of the error in alpha.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">lower</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">target_shape</span> <span class="o">=</span> <span class="n">lower</span><span class="o">.</span><span class="n">shape</span>
        <span class="k">elif</span> <span class="n">upper</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">target_shape</span> <span class="o">=</span> <span class="n">upper</span><span class="o">.</span><span class="n">shape</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="mf">1.0</span>

        <span class="n">lower_std</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">(</span><span class="n">target_shape</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="n">upper_std</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">(</span><span class="n">target_shape</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>

        <span class="c1"># collect the variables involved</span>
        <span class="k">if</span> <span class="n">var_subset</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="nb">vars</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_variables</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="nb">vars</span> <span class="o">=</span> <span class="n">var_subset</span>

        <span class="c1"># first, convert limits to standard normal values</span>
        <span class="k">for</span> <span class="n">var_i</span><span class="p">,</span> <span class="n">var_name</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="nb">vars</span><span class="p">):</span>

            <span class="n">var</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_variables</span><span class="p">[</span><span class="n">var_name</span><span class="p">]</span>

            <span class="k">if</span> <span class="p">(</span><span class="n">lower</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">lower</span><span class="p">[</span><span class="n">var_i</span><span class="p">]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">):</span>
                <span class="n">lower_std</span><span class="p">[</span><span class="n">var_i</span><span class="p">]</span> <span class="o">=</span> <span class="n">norm</span><span class="o">.</span><span class="n">ppf</span><span class="p">(</span><span class="n">var</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">lower</span><span class="p">[</span><span class="n">var_i</span><span class="p">]),</span> <span class="n">loc</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

            <span class="k">if</span> <span class="p">(</span><span class="n">upper</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">upper</span><span class="p">[</span><span class="n">var_i</span><span class="p">]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">):</span>
                <span class="n">upper_std</span><span class="p">[</span><span class="n">var_i</span><span class="p">]</span> <span class="o">=</span> <span class="n">norm</span><span class="o">.</span><span class="n">ppf</span><span class="p">(</span><span class="n">var</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">upper</span><span class="p">[</span><span class="n">var_i</span><span class="p">]),</span> <span class="n">loc</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

        <span class="c1"># then calculate the orthotope results in std normal space</span>
        <span class="n">lower_std</span> <span class="o">=</span> <span class="n">lower_std</span><span class="o">.</span><span class="n">T</span>
        <span class="n">upper_std</span> <span class="o">=</span> <span class="n">upper_std</span><span class="o">.</span><span class="n">T</span>

        <span class="n">OD</span> <span class="o">=</span> <span class="p">[</span><span class="n">mvn_orthotope_density</span><span class="p">(</span><span class="n">mu</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="nb">vars</span><span class="p">)),</span>
                                    <span class="n">COV</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">Rho</span><span class="p">(</span><span class="n">var_subset</span><span class="p">),</span>
                                    <span class="n">lower</span><span class="o">=</span><span class="n">l_i</span><span class="p">,</span> <span class="n">upper</span><span class="o">=</span><span class="n">u_i</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
              <span class="k">for</span> <span class="n">l_i</span><span class="p">,</span> <span class="n">u_i</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">lower_std</span><span class="p">,</span> <span class="n">upper_std</span><span class="p">)]</span>

        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">OD</span><span class="p">)</span></div></div>

<div class="viewcode-block" id="RandomVariableRegistry"><a class="viewcode-back" href="../../common/developer_manual/API/pelicun/API_pelicun_uq.html#pelicun.uq.RandomVariableRegistry">[docs]</a><span class="k">class</span> <span class="nc">RandomVariableRegistry</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Description</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_variables</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_sets</span> <span class="o">=</span> <span class="p">{}</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">RV</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return all random variable(s) in the registry</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_variables</span>

<div class="viewcode-block" id="RandomVariableRegistry.RVs"><a class="viewcode-back" href="../../common/developer_manual/API/pelicun/API_pelicun_uq.html#pelicun.uq.RandomVariableRegistry.RVs">[docs]</a>    <span class="k">def</span> <span class="nf">RVs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">keys</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a subset of the random variables in the registry</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">{</span><span class="n">name</span><span class="p">:</span><span class="bp">self</span><span class="o">.</span><span class="n">_variables</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">keys</span><span class="p">}</span></div>

<div class="viewcode-block" id="RandomVariableRegistry.add_RV"><a class="viewcode-back" href="../../common/developer_manual/API/pelicun/API_pelicun_uq.html#pelicun.uq.RandomVariableRegistry.add_RV">[docs]</a>    <span class="k">def</span> <span class="nf">add_RV</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">RV</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Add a new random variable to the registry.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_variables</span><span class="o">.</span><span class="n">update</span><span class="p">({</span><span class="n">RV</span><span class="o">.</span><span class="n">name</span><span class="p">:</span> <span class="n">RV</span><span class="p">})</span></div>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">RV_set</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the random variable set(s) in the registry.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_sets</span>

<div class="viewcode-block" id="RandomVariableRegistry.add_RV_set"><a class="viewcode-back" href="../../common/developer_manual/API/pelicun/API_pelicun_uq.html#pelicun.uq.RandomVariableRegistry.add_RV_set">[docs]</a>    <span class="k">def</span> <span class="nf">add_RV_set</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">RV_set</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Add a new set of random variables to the registry</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_sets</span><span class="o">.</span><span class="n">update</span><span class="p">({</span><span class="n">RV_set</span><span class="o">.</span><span class="n">name</span><span class="p">:</span> <span class="n">RV_set</span><span class="p">})</span></div>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">RV_samples</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the samples for every random variable in the registry</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">dict</span><span class="p">([(</span><span class="n">name</span><span class="p">,</span> <span class="n">rv</span><span class="o">.</span><span class="n">samples</span><span class="p">)</span> <span class="k">for</span> <span class="n">name</span><span class="p">,</span><span class="n">rv</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">RV</span><span class="o">.</span><span class="n">items</span><span class="p">()])</span>


<div class="viewcode-block" id="RandomVariableRegistry.generate_samples"><a class="viewcode-back" href="../../common/developer_manual/API/pelicun/API_pelicun_uq.html#pelicun.uq.RandomVariableRegistry.generate_samples">[docs]</a>    <span class="k">def</span> <span class="nf">generate_samples</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sample_size</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s1">&#39;LHS_midpoint&#39;</span><span class="p">,</span> <span class="n">seed</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Generates samples for all variables in the registry.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>

<span class="sd">        sample_size: int</span>
<span class="sd">            The number of samples requested per variable.</span>
<span class="sd">        method: {&#39;random&#39;, &#39;LHS&#39;, &#39;LHS_midpoint&#39;}, optional</span>
<span class="sd">            The sample generation method to use. &#39;random&#39; stands for</span>
<span class="sd">            conventional random sampling; &#39;LHS&#39; is Latin HyperCube Sampling</span>
<span class="sd">            with random sample location within each bin of the hypercube;</span>
<span class="sd">            &#39;LHS_midpoint&#39; is like LHS, but the samples are assigned to the</span>
<span class="sd">            midpoints of the hypercube bins.</span>
<span class="sd">        seed: int, optional</span>
<span class="sd">            Random seed used for sampling.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Initialize the random number generator</span>
        <span class="n">rng</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">default_rng</span><span class="p">(</span><span class="n">seed</span><span class="p">)</span>

        <span class="c1"># Generate a dictionary with IDs of the free (non-anchored) variables</span>
        <span class="n">RV_list</span> <span class="o">=</span> <span class="p">[</span><span class="n">RV_name</span> <span class="k">for</span> <span class="n">RV_name</span><span class="p">,</span> <span class="n">RV</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">RV</span><span class="o">.</span><span class="n">items</span><span class="p">()</span> <span class="k">if</span>
                   <span class="n">RV</span><span class="o">.</span><span class="n">anchor</span> <span class="o">==</span> <span class="n">RV</span><span class="p">]</span>
        <span class="n">RV_ID</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">([(</span><span class="n">RV_name</span><span class="p">,</span> <span class="n">ID</span><span class="p">)</span> <span class="k">for</span> <span class="n">ID</span><span class="p">,</span> <span class="n">RV_name</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">RV_list</span><span class="p">)])</span>
        <span class="n">RV_count</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">RV_ID</span><span class="p">)</span>

        <span class="c1"># Generate controlling samples from a uniform distribution for free RVs</span>
        <span class="k">if</span> <span class="s1">&#39;LHS&#39;</span> <span class="ow">in</span> <span class="n">method</span><span class="p">:</span>
            <span class="n">bin_low</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">rng</span><span class="o">.</span><span class="n">permutation</span><span class="p">(</span><span class="n">sample_size</span><span class="p">)</span>
                                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">RV_count</span><span class="p">)])</span>

            <span class="k">if</span> <span class="n">method</span> <span class="o">==</span> <span class="s1">&#39;LHS_midpoint&#39;</span><span class="p">:</span>
                <span class="n">U_RV</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">([</span><span class="n">RV_count</span><span class="p">,</span> <span class="n">sample_size</span><span class="p">])</span> <span class="o">*</span> <span class="mf">0.5</span>
                <span class="n">U_RV</span> <span class="o">=</span> <span class="p">(</span><span class="n">bin_low</span> <span class="o">+</span> <span class="n">U_RV</span><span class="p">)</span> <span class="o">/</span> <span class="n">sample_size</span>

            <span class="k">elif</span> <span class="n">method</span> <span class="o">==</span> <span class="s1">&#39;LHS&#39;</span><span class="p">:</span>
                <span class="n">U_RV</span> <span class="o">=</span> <span class="n">rng</span><span class="o">.</span><span class="n">random</span><span class="p">(</span><span class="n">size</span><span class="o">=</span><span class="p">[</span><span class="n">RV_count</span><span class="p">,</span> <span class="n">sample_size</span><span class="p">])</span>
                <span class="n">U_RV</span> <span class="o">=</span> <span class="p">(</span><span class="n">bin_low</span> <span class="o">+</span> <span class="n">U_RV</span><span class="p">)</span> <span class="o">/</span> <span class="n">sample_size</span>

        <span class="k">elif</span> <span class="n">method</span> <span class="o">==</span> <span class="s1">&#39;random&#39;</span><span class="p">:</span>
            <span class="n">U_RV</span> <span class="o">=</span> <span class="n">rng</span><span class="o">.</span><span class="n">random</span><span class="p">(</span><span class="n">size</span><span class="o">=</span><span class="p">[</span><span class="n">RV_count</span><span class="p">,</span> <span class="n">sample_size</span><span class="p">])</span>

        <span class="c1"># Assign the controlling samples to the RVs</span>
        <span class="k">for</span> <span class="n">RV_name</span><span class="p">,</span> <span class="n">RV_id</span> <span class="ow">in</span> <span class="n">RV_ID</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">RV</span><span class="p">[</span><span class="n">RV_name</span><span class="p">]</span><span class="o">.</span><span class="n">uni_samples</span> <span class="o">=</span> <span class="n">U_RV</span><span class="p">[</span><span class="n">RV_id</span><span class="p">]</span>

        <span class="c1"># Apply correlations for the pre-defined RV sets</span>
        <span class="k">for</span> <span class="n">RV_set_name</span><span class="p">,</span> <span class="n">RV_set</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">RV_set</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="c1"># prepare the correlated uniform distribution for the set</span>
            <span class="n">RV_set</span><span class="o">.</span><span class="n">apply_correlation</span><span class="p">()</span>

        <span class="c1"># Convert from uniform to the target distribution for every RV</span>
        <span class="k">for</span> <span class="n">RV_name</span><span class="p">,</span> <span class="n">RV</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">RV</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">RV</span><span class="o">.</span><span class="n">inverse_transform_sampling</span><span class="p">()</span></div></div>
</pre></div>

           </div>
           
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>
        &#169; Copyright (c) 2018-2021, Leland Stanford Junior University and The Regents of the University of California.

    </p>
  </div>
    
    
    
    Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    
    provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>
        </div>
      </div>

    </section>

  </div>
  

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
    <!-- Theme Analytics -->
    <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

    ga('create', 'UA-158130480-7', 'auto');
    
    ga('send', 'pageview');
    </script>

    
    

  <style>
         .wy-nav-content { max-width: none; }
  </style>

<script>
    /*
    let selectedFilters = [];
    const images  = document.getElementsByClassName("gallery-item");
    const filters = [...document.querySelectorAll('.filter select')];
    const toggles = [...document.querySelectorAll('.filter input')];

    var show = function (elem) {
        elem.style.display = 'block';
    };
    var hide = function (elem) {
        elem.style.display = 'none';
    };
    var toggleFilter =  function(el,elid) {
        const filter = document.getElementById(elid);
        filter.disabled = !el.checked;
       
        if ("createEvent" in document) {
            var evt = document.createEvent("HTMLEvents");
            evt.initEvent("change", false, true);
            filter.dispatchEvent(evt);
        }
        else
            filter.fireEvent("change");
    };
    
    for (const filter of filters) {
        filter.addEventListener('change', function(event) {
            selectedFilters = filters.map(filter => filter.disabled ? '' : filter.value).filter(Boolean);
            console.log(selectedFilters);
            for (const image of images) {
                if (selectedFilters.every(filter => image.classList.contains(filter))) {
                    show(image);
                }
                else {hide(image)};
            };
        })
    };
    */
</script>


</body>
</html>